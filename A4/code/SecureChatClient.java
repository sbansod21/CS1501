
//Sushruti Bansod
//sdb88
//cs1501
import java.util.*;
import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.math.BigInteger;

public class SecureChatClient extends JFrame implements Runnable, ActionListener {

    ////////// declare variables////////////

    // BufferedReader myReader;
    // PrintWriter myWriter;

    public static final int PORT = 8765;

    JTextArea outputArea;
    JLabel prompt;
    JTextField inputField;
    String myName, serverName;
    Socket connection;

    // this is the big difference here
    // need to use this so just find and replace the buffered reader with objstream
    ObjectOutputStream myWriter;
    ObjectInputStream myReader;

    private byte[] encryptName;
    BigInteger E, N, key, encryptKey;

    SymCipher cipher;
    String cType;

    public SecureChatClient() {
        try {

            // use the improved thing for reference
            // first the handshake tig
            myName = JOptionPane.showInputDialog(this, "Enter your user name: "); // grab user name input
            serverName = JOptionPane.showInputDialog(this, "Enter the server name: "); // grab server name inpu
            InetAddress addr = InetAddress.getByName(serverName);
            connection = new Socket(addr, PORT); // Connect to server with new
                                                 // Socket
            // here is where things be different a bit
            // the buffered reader and stuff was just too
            // much in the older version. so we are replacing that with
            // the objectstream

            // initialize the write but unline impro, use the objoutput
            myWriter = new ObjectOutputStream(connection.getOutputStream());

            // i keep getting an error here so apparently i gotts to clean the writer?
            myWriter.flush();

            // initialize the
            myReader = new ObjectInputStream(connection.getInputStream()); // initialize myReader to read from server

            E = (BigInteger) myReader.readObject();
            N = (BigInteger) myReader.readObject();

            // assignment says to print this
            // − Output the keys E and N received from the server to the console

            System.out.println("Key E: " + E);
            System.out.println("Key N: " + N);

            // this is reading the type of encryption method used
            // so in this case either ADD or Sub
            cType = (String) myReader.readObject(); // grab desired encryption type (Add128 or Substitution)

            // assignment says to print this
            // Output the type of symmetric encryption (Add128 or Substitute) to the console
            // once it is received
            // from the server.
            System.out.println("Encryption Method: " + cType);

            // now we gotta determine which ctype to use
            // this ifstatement is easy
            // either sub or add
            if (cType.equalsIgnoreCase("sub")) {
                cipher = new Substitute();
            } else if (cType.equalsIgnoreCase("add")) {
                cipher = new Add128();
            }

            // so the right class is intratiated,
            // get the key

            key = new BigInteger(1, cipher.getKey()); // grab key from SymCipher instance
            // assignment need to print
            // Output the symmetric key that is generated by the client (and will be sent to
            // the server) to the
            // console
            System.out.println("Symmetric Key: " + key);

            // error?? wtf why??????

            // so apparently now that I need to get the right encripted key
            encryptKey = key.modPow(E, N);

            myWriter.writeObject(encryptKey); // send key to server to use for encryption
            myWriter.flush(); // flush to avoid deadlocking

            // It RSA-encrypts the BigInteger version of the key using E and N, and sends
            // the resulting
            // BigInteger to the server (so the server can also determine the key – the
            // server already
            // knows which cipher will be used).
            encryptName = cipher.encode(myName); // encrypt username

            myWriter.writeObject(encryptName);
            myWriter.flush();

            // this ends the Handshake part so
            // the things from here are taken from
            // improved chat cliet
            this.setTitle(myName);

            Box b = Box.createHorizontalBox();
            outputArea = new JTextArea(8, 30);
            outputArea.setEditable(false);
            b.add(new JScrollPane(outputArea));

            outputArea.append("Welcome to the Chat Group, " + myName + "\n");

            inputField = new JTextField("");
            inputField.addActionListener(this);

            prompt = new JLabel("Type your messages below:");
            Container c = getContentPane();

            c.add(b, BorderLayout.NORTH);
            c.add(prompt, BorderLayout.CENTER);
            c.add(inputField, BorderLayout.SOUTH);

            Thread outputThread = new Thread(this);
            outputThread.start();

            addWindowListener(new WindowAdapter() {
                public void windowClosing(WindowEvent e) {
                    // Error again wtff
                    // so im gonna wrap this in a try catch block
                    try {
                        myWriter.writeObject(cipher.encode("CLIENT CLOSING"));
                        myWriter.flush();
                    } catch (IOException io) {
                        System.out.println("Problem closing client!");
                    }
                    System.exit(0);
                }
            });

            setSize(500, 200);
            setVisible(true);

        } catch (Exception e) {
            System.out.println(e);
        }
    }

    public void run() {
        while (true) {
            try {
                // the order to do this is get the message from the server
                // decode it and then make it into a readbale byte format

                // first get the message from the server
                byte[] cryptMsg = (byte[]) myReader.readObject(); // grab encrypted msg from server

                // but rememeber that the message is encrypted
                String currMsg = cipher.decode(cryptMsg); // pass to SymCipher object for decryption
                outputArea.append(currMsg + "\n");
                // so even the decrypted msg is a string
                // need to make it into byes to that use it
                byte[] bytes = currMsg.getBytes(); // convert currMsg to string for output to console

                // For each message that is decrypted, output the following to the console:
                // o The array of bytes received
                // o The decrypted array of bytes
                // o The corresponding String

                System.out.println("Recieved array of bytes: " + Arrays.toString(cryptMsg));
                System.out.println("Decrypted array of bytes: " + Arrays.toString(bytes));
                System.out.println("Corresponding string: " + currMsg);
            } catch (Exception e) {
                System.out.println(e + ", closing client!");
                break;
            }
        }
        System.exit(0);
    }

    public void actionPerformed(ActionEvent e) {
        String currMsg = e.getActionCommand(); // Get input value
        inputField.setText("");
        // myWriter.println(myName + ":" + currMsg); // Add name and send it
        // similar to the run method i need to create a try catch
        // so i can avoid that Io excep
        try {
            // the order is to encode the message into byes
            // write it to the server and then flush
            // myWriter.println(myName + ":" + currMsg);
            // this but make it for the objwriter
            currMsg = myName + ": " + currMsg;

            // similar to the run but backwards cuz we are sending it
            byte[] byteMsg = cipher.encode(currMsg);

            myWriter.writeObject(byteMsg);
            myWriter.flush();

            // For each message that is encrypted, output the following to the console:
            // o The original String message
            // o The corresponding array of bytes
            // o The encrypted array of bytes

            byte[] bytes = currMsg.getBytes();
            System.out.println("Original String Message: " + currMsg);
            System.out.println("Array of bytes: " + Arrays.toString(bytes));
            System.out.println("Encrypted array of bytes: " + Arrays.toString(byteMsg));

        } catch (IOException io) {
            System.err.println("Error: Could not send message to server!");
        }

    }

    public static void main(String[] args) {
        SecureChatClient JR = new SecureChatClient();
        JR.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
    }
}